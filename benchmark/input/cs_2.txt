PaSa: An LLM Agent for Comprehensive Academic Paper Search

Yichen He ∗ 1 Guanhua Huang ∗ 1 Peiyuan Feng 1 Yuan Lin † 1 Yuchen Zhang 1 Hang Li 1 Weinan E 2

1 ByteDance Research 2 Peking University

{hyc,huangguanhua,fpy,linyuan.0}@bytedance.com,

{zhangyuchen.zyc,lihang.lh}@bytedance.com, weinan@math.pku.edu.cn

Demo: https://pasa-agent.ai

<missing-text>

Paper Search

Abstract

1 Introduction

We introduce PaSa, an advanced Pa per S e a rch agent powered by large language models. PaSa can autonomously make a series of decisions, including invoking search tools, reading papers, and selecting relevant references, to ultimately obtain comprehensive and accurate results for complex scholarly queries. We optimize PaSa using reinforcement learning with a synthetic dataset, AutoScholarQuery, which includes 35k fine-grained academic queries and corresponding papers sourced from top-tier AI conference publications. Additionally, we develop RealScholarQuery, a benchmark collecting real-world academic queries to assess PaSa performance in more realistic scenarios. Despite being trained on synthetic data, PaSa significantly outperforms existing baselines on RealScholarQuery, including Google, Google Scholar, Google with GPT-4 for paraphrased queries, chatGPT (search-enabled GPT-4o), GPT-o1, and PaSa-GPT-4o (PaSa implemented by prompting GPT-4o). Notably, PaSa-7B surpasses the best Google-based baseline, Google with GPT-4o, by 37.78% in recall@20 and 39.90% in recall@50. It also exceeds PaSaGPT-4o by 30.36% in recall and 4.25% in precision. Model, datasets, and code are available at https://github.com/bytedance/pasa .

Academic paper search lies at the core of research yet represents a particularly challenging information retrieval task. It requires long-tail specialized knowledge, comprehensive survey-level coverage, and the ability to address fine-grained queries. For instance, consider the query: "Which studies have focused on non-stationary reinforcement learning using value-based methods, specifically UCB-based algorithms?" While widely used academic search systems like Google Scholar are effective for general queries, they often fall short when addressing these complex queries (Gusenbauer and Haddaway, 2020). Consequently, researchers frequently spend substantial time conducting literature surveys (Kingsley et al., 2011; Gusenbauer and Haddaway, 2021).

The advancements in large language models (LLMs) (OpenAI, 2023; Anthropic, 2024; Gemini, 2023; Yang et al., 2024) have inspired numerous studies leveraging LLMs to enhance information retrieval, particularly by refining or reformulating search queries to improve retrieval quality (Alaofi et al., 2023; Li et al., 2023; Ma et al., 2023; Peng et al., 2024). In academic search, however, the process goes beyond simple retrieval. Human researchers not only use search tools, but also engage in deeper activities, such as reading relevant papers and checking citations, to perform comprehensive and accurate literature surveys.

<missing-text>

In this paper, we introduce PaSa, a novel paper search agent designed to mimic human behavior for comprehensive and accurate academic paper searches. As illustrated in Figure 1, PaSa consists of two LLM agents: the Crawler and the Selector. For a given user query, the Crawler can autonomously collect relevant papers by utilizing search tools or extracting citations from the current paper, which are then added to a growing paper queue . The Crawler iteratively processes each paper in the paper queue, navigating citation networks to discover increasingly relevant papers. The Selector carefully reads each paper in the paper queue to determine whether it meets the requirements of the user query. We optimize PaSa within the AGILE, a reinforcement learning (RL) framework for LLM agents (Feng et al., 2024).

Effective training requires high-quality academic search data. Fortunately, human scientists have already created a vast amount of high-quality academic papers, which contain extensive surveys on a wide range of research topics. We build a synthetic but high-quality academic search dataset, AutoScholarQuery, which collects fine-grained scholar queries and their corresponding relevant papers from the related work sections of papers published at ICLR 2023 1 , ICML 2023 2 , NeurIPS 2023 3 , ACL 2024 4 , and CVPR 2024 5 . AutoScholarQuery includes 33,511 / 1,000 / 1,000 query-paper pairs in the training / development / test split.

Although AutoScholarQuery only provides query and paper answers, without demonstrating the path by which scientists collect the papers, we can utilize them to perform RL training to improve PaSa. In addition, we design a new session-level PPO (Proximal Policy Optimization (Schulman et al., 2017)) training method to address the unique challenges of the paper search task: 1) sparse reward: The papers in AutoScholarQuery are collected via citations, making it a smaller subset of the actual qualified paper set. 2) long trajectories: The complete trajectory of the Crawler may involve hundreds of papers, which is too long to directly input into the LLM context.

To evaluate PaSa, besides the test set of AutoScholarQuery, we also develop a benchmark, RealScholarQuery. It contains 50 real-world academic queries with annotated relevant papers, to assess PaSa in real-world scenarios. We compare PaSa with several baselines including Google, Google Scholar, Google paired with GPT-4o for paraphrased queries, chatGPT (search-enabled GPT4o), GPT-o1 and PaSa-GPT-4o (PaSa agent realized by prompting GPT-4o). Our experiments show that PaSa-7b significantly outperforms all baselines. Specifically, for AutoScholarQuery test set, PaSa7b achieves a 34.05% improvement in Recall@20 and a 39.36% improvement in Recall@50 compared to Google with GPT-4o, the strongest Googlebased baseline. PaSa-7b surpasses PaSa-GPT-4o by 11.12% in recall, with similar precision. For RealScholarQuery, PaSa-7b outperforms Google with GPT-4o by 37.78% in Recall@20 and 39.90% in Recall@50. PaSa-7b surpasses PaSa-GPT-4o by 30.36% in recall and 4.25% in precision.

The main contributions of this paper are summarized as follows:

 · We introduce PaSa, a comprehensive and accurate paper search agent that can autonomously use online search tools, read entire papers, and navigate citation networks.

 · We develop two high-quality datasets for complex academic search, AutoScholarQuery and RealScholarQuery.

 · Although PaSa is trained solely on synthetic data, it achieves remarkable real-world performance. Experiments demonstrate that PaSa, built on 7B LLM, significantly outperforms all baselines, including GPT-4 agent, Googlebased search, and chatGPT.

2 Related Work

LLMs in Scientific Discovery LLMs have been applied across various stages of scientific discovery (Van Noorden and Perkel, 2023; Lu et al., 2024; Messeri and Crockett, 2024; Liao et al., 2024), such as brainstorming ideas (Girotra et al., 2023; Wang et al., 2024a; Baek et al., 2024), designing experiments (M. Bran et al., 2024), writing code (Xu et al., 2022), and generating research papers (Shao et al., 2024; Agarwal et al., 2024; Wang et al., 2024b). One of the most fundamental yet critical stages in research is conducting academic surveys. Despite its importance, current tools like Google Scholar are often insufficient, leading researchers to spend considerable time on literature review tasks (Kingsley et al., 2011; Gusenbauer and Haddaway, 2021, 2020). This challenge motivates us to develop PaSa, an LLM agent designed to autonomously and comprehensively assist researchers in collecting relevant research papers for complex scholarly queries.

LLM Agents LLM Agents combine LLMs with memory, tool use, and planning, enabling them to perform more complex tasks such as personal copilots (Stratton, 2024), travel planning (Gundawar et al., 2024), web operations (Deng et al., 2024), software development (Qian et al., 2023), and scientific experimentation (Bran et al., 2023). In addition to realizing LLM Agents through prompt engineering (Park et al., 2023; Yao et al., 2023; Shinn et al., 2024; Chen et al., 2023), recent research has focused on optimizing and training these agents (Feng et al., 2024; Putta et al., 2024; Liu

et al., 2023). Among these efforts, AGILE (Feng et al., 2024), a reinforcement learning framework for LLM agents, allows the joint optimization of all agent skills in an end-to-end manner. In our work, we adopt the AGILE framework to implement PaSa. Specifically, we design a novel session-level PPO algorithm to address the unique challenges of the paper search task, including sparse rewards and long trajectories.

3 Datasets

3.1 AutoScholarQuery

AutoScholarQuery is a synthetic but high-quality dataset of academic queries and related papers, specifically curated for the AI field.

To construct AutoScholarQuery, we began by collecting all papers published at ICLR 2023, ICML 2023, NeurIPS 2023, ACL 2024, and CVPR 2024. For the Related Work section of each paper, we prompted GPT-4o (Hurst et al., 2024) to generate scholarly queries, where the answers to these queries correspond to the references cited in the Related Work section. The prompt used is shown in Appendix E.1. For each query, we retained only the papers that could be retrieved on arXiv 6 , using their arxiv\_id as the unique article identifier in the dataset. We adopt the publication date of the source paper as the query date. During both training and testing, we only considered papers published prior to the query date.

The final AutoScholarQuery dataset comprises 33,551, 1,000, and 1,000 instances in the training, development, and testing splits, respectively. Each instance consists of a query, the associated paper set, and the query date, with queries in each split derived from distinct source papers. Table 1 provides illustrative examples from AutoScholarQuery, while additional dataset statistics are summarized in Table 2.

To evaluate the quality of AutoScholarQuery, we sampled 100 query-paper pairs and assessed the rationality and relevance of each query and the corresponding paper. A qualified query should be meaningful and unambiguous. A qualified paper should match the requirements of the scholarly query. The author manually reviewed each pair, determining that 94.0% of the queries were qualified. Among these qualified queries, 93.7% had corresponding papers that were deemed relevant and appropriate.

<missing-text>

<missing-text>

3.2 RealScholarQuery

To evaluate PaSa in more realistic scenarios, we constructed RealScholarQuery, a test dataset consisting of 50 real-world research queries. After launching the demo of PaSa, we invited several AI researchers to use the system. From the queries they provided, we randomly sampled a subset of queries and manually filtered out overly broad topics (e.g., "multi-modal large language models," "video generation"). Ultimately, we collected 50 fine-grained and realistic queries.

For each query, we first manually gathered relevant papers. Subsequently, we used multiple methods to retrieve additional papers, including PaSa, Google, Google Scholar, ChatGPT (search-enabled GPT-4o), and Google paired with GPT-4o for paraphrased queries. The results from these methods were aggregated into a pool of candidate papers. Finally, professional annotators reviewed all candidate papers for each query, selecting those that

met the specific requirements of the query to create the final set of relevant papers. The query date of all instances in RealScholarQuery is 2024-10-01. Table 12 in Appendix D provides examples from RealScholarQuery.

The annotators included professors from the Department of Computer Science at a top-tier university in China. On average, each query required the annotators to review 76 candidate papers. Given the high cost of the annotations, we completed this process for only 50 instances.

4 Methodology

4.1 Overview

As illustrated in Figure 1, the PaSa system consists of two LLM agents: Crawler and Selector. The crawler reads the user's query, generates multiple search queries, and retrieves relevant papers. The retrieved papers are added to a paper queue . The Crawler further processes each paper in the paper queue to identify key citations worth exploring further, appending any newly relevant papers to the paper list. The selector conducts a thorough review of each paper in the paper list to assess whether it fulfills the user's query requirements.

In summary, the Crawler is designed to maximize the recall of relevant papers, whereas the Selector emphasizes precision in identifying papers that meet the user's needs.

Is there any works that analyze the scaling law of the multi-module models, such as video-text, image-text models.

<missing-text>

<missing-text>

4.2 Crawler

In RL terminology, the Crawler performs a tokenlevel Markov Decision Process (MDP). The action space A corresponds to the LLM's vocabulary, where each token represents an action. The LLM functions as the policy model. The agent's state is defined by the current LLM context and the paper queue. The Crawler operates with three registered functions, as outlined in Table 3. When an action matches a function name, the corresponding function is executed, further modifying the agent's state.

For example, as Figure 2 shows, the agent begins by receiving a user query, incorporating it into its context, and initiating actions. If the token generated is [Search] , the LLM continues to generate a search query, and the agent invokes a search tool to retrieve papers, which are then added to the paper list. If the token is [Expand] , the LLM continues to extract a subsection name from the current pa-

per in its context. The agent subsequently uses a parsing tool to extract all referenced papers within that subsection, adding them to the paper list. If the token is [Stop] , the agent resets its context to the user query and information of the next paper in the paper queue. This information includes the title, abstract, and an outline of all sections and subsections.

The training process for the Crawler comprises two stages. In the first stage, we generate trajectories for a small subset of the training data and then perform imitation learning (see Appendix A.1 for details). In the second stage, reinforcement learning is applied. The details of the RL training implementation are described below.

Reward Design We conduct RL training on the AutoScholarQuery training set, where each instance consists of a query q and a corresponding paper set P . Starting with a query q , the Crawler generates a trajectory τ = ( s 1 , a 1 , · · · , s T , a T ) . At each time step t , we denote the current paper queue as Q t . Upon taking action a t , the Crawler appends a set of new papers ( p 1 , p 2 , · · · , p n t ) to the paper queue. If a t = [Stop] , the set is empty.

The reward of executing action a t in state s t is defined as

r ( s t , a t ) = α × n t ∑ i =1 I ( q, p i , t ) -c ( a t ) , (1)

where I ( q, p i , t ) = 1 if p i matches the query q and is not already in Q t , and I ( q, p i , t ) = 0 otherwise.

Here, α is a reward coefficient, and c ( a t ) is the cost of action a t .

The indicator function I ( q, p i , t ) can be determined by checking if p i belongs to P - Q t . However, it is important to note that the AutoScholarQuery may only include a subset of the groundtruth papers, as citations often emphasize a limited number of key references. If the Crawler receives rewards solely based on matching papers in AutoScholarQuery, this could lead to sparse rewards during training. To mitigate this, we use the Selector as an auxiliary reward model for the Crawler. The revised definition of I ( q, p i , t ) is:

I ( q, p i , t ) =      1 , if ( Selector ( q, p i ) = 1 or p i ∈ P ) and p i / ∈ Q t , 0 , otherwise. (2)

Here Selector ( q, p i ) = 1 if paper p i is identified as correct to meet the query q by the Selector, and Selector ( q, p i ) = 0 otherwise.

RL Training A key challenge in training the Crawler with RL is the significant time required to sample a complete trajectory for a given query. This is due to each [Search] or [Expand] action adding multiple papers to the paper list, resulting in hundreds or even thousands of papers in the final paper queue.

To address this issue, we define a session as a sub-trajectory that begins with a session's initial state and ends with the [Stop] action. We identify two types of session initial states: S q , which includes only a query, and S q + p , which consists of both a query and a paper.

Formally, we model the Crawler as a policy π θ ( a t | s t ) . We partition the entire trajectory τ into a sequence of sessions: ( τ t 1 : t 2 -1 , τ t 2 : t 3 -1 , · · · ) . Each session is τ t i : t i +1 -1 = ( s t i , a t i , · · · , s t i +1 -1 , a t i +1 -1 ) , where the initial state s t i is either belonging to type S q or S q + p , and the final action a t i +1 -1 is [STOP] .

Sampling such a sub-trajectory from these session initial states is computationally efficient. During the PPO training, at time step t ∈ [ t i , t i +1 ) , we estimate the return in the session using Monte Carlo sampling:

ˆ R t = t i +1 -1 -t ∑ k =0 γ k 0 [ r ( s t + k , a t + k ) (3) + γ 1 n t + k ∑ j =1 ˆ V ϕ ( S q + p j ) -β · log π θ ( a t | s t ) π sft ( a t | s t ) ]

Here, γ 0 is the in-session discount factor, and γ 1 is the across-session discount factor. ˆ V ϕ ( · ) is the value function model to approximate the state value. After executing a t + k , the paper queue is updated to include the newly found papers ( p 1 , p 2 , · · · , p n t + k ) . Since the Crawler will subsequently initiate new sessions to process these additional papers, their associated reward-to-go should be incorporated into the return estimate. In addition, we include a per-token KL penalty term from the learned policy π θ to the initial policy π sft obtained through imitation learning at each token to mitigate over-optimization. This term is scaled by the coefficient β .

Then the advantage function can be approximated by

ˆ A ( s t , a t ) = ˆ R t -ˆ V ϕ ( s t ) . (4)

Finally, the policy and value objectives can be given by

L policy ( θ ) = E τ ' ∼ π old θ [ min ( π θ ( a t | s t ) π old θ ( a t | s t ) ˆ A ( s t , a t ) , (5) clip ( π θ ( a t | s t ) π old θ ( a t | s t ) , 1 -ϵ, 1 + ϵ ) ˆ A ( s t , a t ) ) ]

and

L value ( ϕ ) = E τ ' ∼ π old θ [ max ( ( ˆ R t -ˆ V ϕ (s t ) ) 2 , (6) ( ˆ R t -ˆ V clip ϕ ( s t ) ) 2 ) ] ,

respectively, where

ˆ V clip ϕ ( s t ) = clip ( ˆ V ϕ ( s t ) , V old ϕ ( s t ) -ϵ, V old ϕ ( s t ) + ϵ ) . (7)

Here, π old θ and V old ϕ is used for sampling and τ ' is session trajectory. We then combine these into the unified RL loss:

L RL ( θ, ϕ ) = L policy ( θ ) + η · L value ( ϕ ) (8)

where η is the coefficient of the value objective.

4.3 Selector

The Selector is an LLM agent that takes two inputs: a scholar query and a research paper (including its title and abstract). It generates two outputs: (1) a single decision token d , either "True" or "False", indicating whether the paper satisfies the query,

and (2) a rationale r = ( r 1 , r 2 , ..., r m ) containing m tokens that support this decision. The rationale serves two purposes: enhancing decision accuracy by jointly training the model to generate decisions and explanations, and improving user trust by providing the reasoning in PaSa application.

To optimize training efficiency for the Crawler, the decision token is presented before the rationale, allowing the Selector to act as a single-token reward model during the Crawler training. Additionally, the token probability of the decision token can be used to rank search results. At last, as shown in Table 7, the order of the decision and rationale does not affect the Selector's performance.

We perform imitation learning to optimize the Selector. See Appendix B for training data collection and training details.

5 Experiments

5.1 Experimental Setting

We sequentially trained the Selector and Crawler, both based on the Qwen2.5-7b (Yang et al., 2024), to develop the final agent, referred to as PaSa-7b.

Selector The Selector was fine-tuned using the training dataset described in Appendix B. We conducted supervised fine-tuning for one epoch with a learning rate of 1e-5 and a batch size of 4. The training runs on 8 NVIDIA-H100 GPUs.

Crawler The training process involves two stages. First, we perform imitation learning for 1 epoch on 12,989 training data with a learning rate of 1e-5 and batch size of 4 per device, using 8 NVIDIA H100 GPUs. In the second stage, we apply PPO training. To ensure stability, we first freeze the policy model and train the value model, followed by co-training both the policy and value models. The hyperparameters used during the training process are listed in the Table 4.

During imitation learning, the model encounters 5,000 queries, while during the RL training phase, the model processes a total of 16,000 queries. For more details please refer to Appendix A.1 for the imitation learning data construction and Appendix A.2 for the PPO training data sampling.

Implementation of [Search] This function utilizes the LLM to predict a query based on the context, and then calls Google 7 with the parameters site:arxiv.org and before:query\_date ,

<missing-text>

restricting search results by source and publication time.

Paper Management We developed a database to manage and restore research papers. PaSa retrieves paper information from the database. If no matching record is found, we use ar5iv 8 to obtain the full paper content, including citations, and then parse this data and store it in the database.

5.2 Baselines and Evaluation

We evaluate our paper search agent on both the test set of AutoScholarQuery and RealScholarQuery. We compare PaSa-7b against the following baselines:

 · Google. We use Google to search the query directly, with the same parameter settings in Section 5.1.

 · Google Scholar. Queries are submitted directly to Google Scholar 7 , with the same parameter settings in Section 5.1.

 · Google with GPT-4o. We first employ GPT4o to paraphrase the scholar query. The paraphrased query is then searched on Google.

 · ChatGPT. We submit the scholar query to ChatGPT 9 , powered by search-enabled GPT4o. Due to the need for manual query submis-

<missing-text>

<missing-text>

on, we evaluate only 100 randomly sampled instances from the AutoScholarQuery test set.

 · GPT-o1. Prompt GPT-o1 to process the scholar query.

 · PaSa-GPT-4o. Prompt GPT-4o within the PaSa framework. It can perform multiple searches, paper reading, and citation network crawling.

We carefully designed prompts for all baselines and they are shown in Appendix E.1.

As shown in Figure 2, the crawling process of PaSa can be visualized as a paper tree. In practice, considering the computational expense, we limit the Crawler's exploration depth (starting from the user query) to three for both PaSa-7b and PaSaGPT-4o.

For Google-based baselines, we evaluate recall using Recall@20, Recall@50, and Recall@100 metrics for the top-20, top-50, and top-100 search results, respectively. For other baselines, we assess precision and recall for the final retrieved papers. Additionally, we compare the crawler's recall between PaSa-GPT-4o and PaSa-7b.

5.3 Main results

As shown in Table 5, PaSa-7b outperforms all baselines on AutoScholarQuery test set. Specifically,

compared to the strongest baseline, PaSa-GPT-4o, PaSa-7b demonstrates a 9.64% improvement in recall with comparable precision. Moreover, the recall of the Crawler in PaSa-7b is 3.66% higher than that in PaSa-GPT-4o. When compared to the best Google-based baseline, Google with GPT-4o, PaSa7b achieves an improvement of 33.80%, 38.83% and 42.64% in Recall@20, Recall@50 and Recall@100, respectively.

We observe that using multiple ensembles of Crawler during inference can improve performance. Specifically, running Crawler twice during inference increased the Crawler recall by 3.34% on AutoScholarQuery, leading to the final recall improvement by 1.51%, with precision remaining similar.

To evaluate PaSa in a more realistic setting, we assess its effectiveness on RealScholarQuery. As illustrated in Table 6, PaSa-7b exhibits a greater advantage in real-world academic search scenarios. Compared to PaSa-GPT-4o, PaSa-7b achieves improvements of 30.36% in recall and 4.25% in precision. Against the best Google-based baseline on RealScholarQuery, Google with GPT-4o, PaSa7b outperforms Google by 37.78%, 39.90%, and 39.83% in recall@20, recall@50 and recall@100, respectively. Additionally, the PaSa-7b-ensemble further enhances crawler recall by 4.32%, contributing to an overall 3.52% improvement in the recall

of the entire agent system.

As both the final decision-maker and auxiliary reward model in RL training for the Crawler, the performance of the Selector is crucial. To evaluate its effectiveness, we collected a dataset of 200 query-paper pairs, annotating whether each paper meets the query's requirements. This dataset serves as the benchmark for evaluating the Selector (see Appendix C for details). We then compared our Selector against GPT-4o (Hurst et al., 2024) and Qwen-2.5-7b (Yang et al., 2024), as shown in Table 7. The results show that our Selector achieves an F1 score of 85%, outperforming GPT-4o by 5% and Qwen-2.5-7b by 30%. Additionally, when compared to a setting where reasoning precedes decision token generation, the performance is comparable. Lastly, the Selector's precision reaches 95%, confirming its effectiveness as an auxiliary reward model for the Crawler RL training.

<missing-text>

5.4 Ablation study

We perform ablation studies in Table 8 to evaluate the individual contributions of exploring citation networks, RL training, and using the Selector as the reward model. The results indicate that removing the [Expand] action from the Crawler leads to a significant drop in the recall: a decrease of 22.98% on AutoScholarQuery and 32.21% on RealScholarQuery. Furthermore, RL training enhances recall by 6.24% on AutoScholarQuery and 19.96% on RealScholarQuery. The RL training curves are depicted in Figure 3, where the training curves show a steady increase in return with the training steps, eventually converging after 200 steps. Finally, removing the Selector as an auxiliary reward model results in a 3.76% recall drop on AutoScholarQuery and a 9.63% drop on RealScholarQuery.

We investigate how to control agent behavior by adjusting the rewards in RL training. Experiments are conducted with varying reward coefficients α in Equation 1, and results are presented in Table 9. We report two metrics: crawler recall and crawler action. The crawler action refers to the total number of [Search] and [Expand] actions throughout the

Crawler's entire trajectory. As the reward increases, both crawler recall and crawler action increase, suggesting that adjusting rewards in RL training can effectively influence PaSa's behavior.

<missing-text>

6 Conclusion

In this paper, we introduce PaSa, a novel paper search agent designed to provide comprehensive and accurate results for complex academic queries. PaSa is implemented within the AGILE, a reinforcement learning framework for LLM agents. To train PaSa, we developed AutoScholarQuery, a dataset of fine-grained academic queries and corresponding papers drawn from top-tier AI conference publications. To evaluate PaSa in real-world scenarios, we also constructed RealScholarQuery, a dataset of actual academic queries paired with annotated papers. Our experimental results demonstrate that PaSa outperforms all baselines, including Google, Google Scholar, and Google with GPT-4o, ChatGPT, GPT-o1, and PaSa-GPT-4o. In particular, PaSa-7B surpasses Google with GPT-4o by 37.78% in recall@20 and 39.90% in recall@50, while also exceeding PaSa-GPT-4o by 30.36% in recall and 4.25% in precision. These findings underscore PaSa significantly improves the efficiency and accuracy of academic search.

<missing-text>

<missing-text>

References

Shubham Agarwal, Issam H Laradji, Laurent Charlin, and Christopher Pal. 2024. Litllm: A toolkit for scientific literature review. arXiv preprint arXiv:2402.01788 .

Marwah Alaofi, Luke Gallagher, Mark Sanderson, Falk Scholer, and Paul Thomas. 2023. Can generative llms create query variants for test collections? an exploratory study. In Proceedings of the 46th international ACM SIGIR conference on research and development in information retrieval , pages 18691873.

 A Anthropic. 2024. The claude 3 model family: Opus, sonnet, haiku; 2024. URL https://wwwcdn.anthropic.com/de8ba9b01c9ab7cbabf5c33b80b7 bbc618857627/Model\_Card\_Claude\_3.pdf .

Jinheon Baek, Sujay Kumar Jauhar, Silviu Cucerzan, and Sung Ju Hwang. 2024. Researchagent: Iterative research idea generation over scientific literature with large language models. arXiv preprint arXiv:2404.07738 .

Andres M Bran, Sam Cox, Oliver Schilter, Carlo Baldassari, Andrew D White, and Philippe Schwaller. 2023. Chemcrow: Augmenting large-language models with chemistry tools. arXiv preprint arXiv:2304.05376 .

Guangyao Chen, Siwei Dong, Yu Shu, Ge Zhang, Jaward Sesay, Börje F Karlsson, Jie Fu, and Yemin Shi. 2023. Autoagents: A framework for automatic agent generation. arXiv preprint arXiv:2309.17288 .

Xiang Deng, Yu Gu, Boyuan Zheng, Shijie Chen, Sam Stevens, Boshi Wang, Huan Sun, and Yu Su. 2024. Mind2web: Towards a generalist agent for the web. Advances in Neural Information Processing Systems , 36.

Peiyuan Feng, Yichen He, Guanhua Huang, Yuan Lin, Hanchong Zhang, Yuchen Zhang, and Hang Li. 2024. Agile: A novel framework of llm agents. arXiv preprint arXiv:2405.14751 .

Team Gemini. 2023. Gemini: a family of highly capable multimodal models. arXiv preprint arXiv:2312.11805 .

Karan Girotra, Lennart Meincke, Christian Terwiesch, and Karl T Ulrich. 2023. Ideas are dimes a dozen: Large language models for idea generation in innovation. Available at SSRN 4526071 .

Atharva Gundawar, Mudit Verma, Lin Guan, Karthik Valmeekam, Siddhant Bhambri, and Subbarao Kambhampati. 2024. Robust planning with llm-modulo framework: Case study in travel planning. arXiv preprint arXiv:2405.20625 .

Michael Gusenbauer and Neal R Haddaway. 2020. Which academic search systems are suitable for systematic reviews or meta-analyses? evaluating retrieval qualities of google scholar, pubmed, and 26 other resources. Research synthesis methods , 11(2):181-217.

Michael Gusenbauer and Neal R Haddaway. 2021. What every researcher should know about searchingclarified concepts, search advice, and an agenda to improve finding in academia. Research synthesis methods , 12(2):136-147.

Aaron Hurst, Adam Lerer, Adam P Goucher, Adam Perelman, Aditya Ramesh, Aidan Clark, AJ Ostrow, Akila Welihinda, Alan Hayes, Alec Radford, et al. 2024. Gpt-4o system card. arXiv preprint arXiv:2410.21276 .

Karl Kingsley, Gillian M Galbraith, Matthew Herring, Eva Stowers, Tanis Stewart, and Karla V Kingsley. 2011. Why not just google it? an assessment of information literacy skills in a biomedical science curriculum. BMC medical education , 11:1-8.

Minghan Li, Honglei Zhuang, Kai Hui, Zhen Qin, Jimmy Lin, Rolf Jagerman, Xuanhui Wang, and Michael Bendersky. 2023. Generate, filter, and fuse: Query expansion via multi-step keyword generation for zero-shot neural rankers. arXiv preprint arXiv:2311.09175 .

Zhehui Liao, Maria Antoniak, Inyoung Cheong, Evie Yu-Yen Cheng, Ai-Heng Lee, Kyle Lo, Joseph Chee

Chang, and Amy X Zhang. 2024. Llms as research tools: A large scale survey of researchers' usage and perceptions. arXiv preprint arXiv:2411.05025 .

Zhihan Liu, Hao Hu, Shenao Zhang, Hongyi Guo, Shuqi Ke, Boyi Liu, and Zhaoran Wang. 2023. Reason for future, act for now: A principled framework for autonomous llm agents with provable sample efficiency. arXiv preprint arXiv:2309.17382 .

Chris Lu, Cong Lu, Robert Tjarko Lange, Jakob Foerster, Jeff Clune, and David Ha. 2024. The ai scientist: Towards fully automated open-ended scientific discovery. arXiv preprint arXiv:2408.06292 .

Andres M. Bran, Sam Cox, Oliver Schilter, Carlo Baldassari, Andrew D White, and Philippe Schwaller. 2024. Augmenting large language models with chemistry tools. Nature Machine Intelligence , pages 1-11.

Xinbei Ma, Yeyun Gong, Pengcheng He, Hai Zhao, and Nan Duan. 2023. Query rewriting for retrievalaugmented large language models. arXiv preprint arXiv:2305.14283 .

Lisa Messeri and MJ Crockett. 2024. Artificial intelligence and illusions of understanding in scientific research. Nature , 627(8002):49-58.

OpenAI. 2023. Gpt-4 technical report. arXiv preprint arXiv:2303.08774 .

Joon Sung Park, Joseph O'Brien, Carrie Jun Cai, Meredith Ringel Morris, Percy Liang, and Michael S Bernstein. 2023. Generative agents: Interactive simulacra of human behavior. In Proceedings of the 36th Annual ACM Symposium on User Interface Software and Technology , pages 1-22.

Wenjun Peng, Guiyang Li, Yue Jiang, Zilong Wang, Dan Ou, Xiaoyi Zeng, Derong Xu, Tong Xu, and Enhong Chen. 2024. Large language model based long-tail query rewriting in taobao search. In Companion Proceedings of the ACM on Web Conference 2024 , pages 20-28.

Pranav Putta, Edmund Mills, Naman Garg, Sumeet Motwani, Chelsea Finn, Divyansh Garg, and Rafael Rafailov. 2024. Agent q: Advanced reasoning and learning for autonomous ai agents. arXiv preprint arXiv:2408.07199 .

Chen Qian, Xin Cong, Cheng Yang, Weize Chen, Yusheng Su, Juyuan Xu, Zhiyuan Liu, and Maosong Sun. 2023. Communicative agents for software development. arXiv preprint arXiv:2307.07924 .

John Schulman, Filip Wolski, Prafulla Dhariwal, Alec Radford, and Oleg Klimov. 2017. Proximal policy optimization algorithms. arXiv preprint arXiv:1707.06347 .

Yijia Shao, Yucheng Jiang, Theodore Kanell, Peter Xu, Omar Khattab, and Monica Lam. 2024. Assisting in writing Wikipedia-like articles from scratch with large language models. In Proceedings of the 2024

Conference of the North American Chapter of the Association for Computational Linguistics: Human Language Technologies (Volume 1: Long Papers) , pages 6252-6278, Mexico City, Mexico. Association for Computational Linguistics.

Noah Shinn, Federico Cassano, Ashwin Gopinath, Karthik Narasimhan, and Shunyu Yao. 2024. Reflexion: Language agents with verbal reinforcement learning. Advances in Neural Information Processing Systems , 36.

Jess Stratton. 2024. An introduction to microsoft copilot. In Copilot for Microsoft 365: Harness the Power of Generative AI in the Microsoft Apps You Use Every Day , pages 19-35. Springer.

Richard Van Noorden and Jeffrey M Perkel. 2023. Ai and science: what 1,600 researchers think. Nature , 621(7980):672-675.

Qingyun Wang, Doug Downey, Heng Ji, and Tom Hope. 2024a. SciMON: Scientific inspiration machines optimized for novelty. In Proceedings of the 62nd Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers) , pages 279-299, Bangkok, Thailand. Association for Computational Linguistics.

Yidong Wang, Qi Guo, Wenjin Yao, Hongbo Zhang, Xin Zhang, Zhen Wu, Meishan Zhang, Xinyu Dai, Min Zhang, Qingsong Wen, et al. 2024b. Autosurvey: Large language models can automatically write surveys. arXiv preprint arXiv:2406.10252 .

Frank F Xu, Uri Alon, Graham Neubig, and Vincent Josua Hellendoorn. 2022. A systematic evaluation of large language models of code. In Proceedings of the 6th ACM SIGPLAN International Symposium on Machine Programming , pages 1-10.

An Yang, Baosong Yang, Beichen Zhang, Binyuan Hui, Bo Zheng, Bowen Yu, Chengyuan Li, Dayiheng Liu, Fei Huang, Haoran Wei, et al. 2024. Qwen2. 5 technical report. arXiv preprint arXiv:2412.15115 .

Shunyu Yao, Jeffrey Zhao, Dian Yu, Nan Du, Izhak Shafran, Karthik Narasimhan, and Yuan Cao. 2023. React: synergizing reasoning and acting in language models (2022). arXiv preprint arXiv:2210.03629 .

A Implementation Details of the Crawler

A.1 Imitation learning data generation

We generate training data for imitation learning on a session-by-session basis. There are two types of sessions: search session (starting from state S q ) and expand session (starting from state S q + p ).

For search sessions starting from S q , we sample user queries from the AutoScholarQuery training set and prompt GPT-4o to generate corresponding search queries. The prompt template is shown in Table 10. The session trajectory is constructed

by adding a [Search] token before each query, concatenating the queries, and appending a [Stop] token at the end, as shown in Table 11. A total of 3,011 search session trajectories are generated.

For expand sessions starting from S q + p , we continue by searching for the generated queries using Google. We then sample papers from the search results and obtain the initial state, which includes both the query and a paper. To build the session trajectory, we examine each sub-section of the paper. If the sub-section references at least one paper in the AutoScholarQuery training set corresponding to the query, the sub-section is selected. Otherwise, the sub-section is selected with a 10% probability to enhance trajectory diversity. The selected sections are filled into the template in Table 11, completing the session trajectory. In total, 9,978 expand session trajectories are constructed.

A.2 Roll-Out in PPO training

During PPO training, each device processes 4 user queries in each step, generating a search session for each user query. Then, 6 expansion sessions are created by randomly sampling 6 papers from the search results. This process is repeated with the expand citation results, yielding 6 additional expand sessions. In total, 16 session trajectories are generated per step.

B Implementation Details of the Selector

We begin by sampling user queries from the AutoScholarQuery training set. For each user query and one of its corresponding papers in the AutoScholarQuery training set, we prompt GPT-4o to generate a decision token and rationale (see Table 15 for prompt). We reject any data where the decision token is "False", as this contradicts the AutoScholarQuery label. The remaining data are retained as positive <user query, paper> pairs.

Next, we simulate a partial paper search using PaSa-GPT-4o. In this simulation, each paper has a 50% probability of being added to the paper queue. Pairs where the paper is not selected by GPT-4o and is not in the AutoScholarQuery training set are labeled as negative examples.

The final training dataset consists of 19,812 <user query, paper> pairs, each with a decision token and rationale generated by GPT-4o, drawn from 9,000 instances in the AutoScholarQuery training set.

C Selector Test Dataset

We select 200 queries from the AutoScholarQuery development set. For each query, we perform a Google search and randomly choose one paper from the union of the search results and the relevant paper set in AutoScholarQuery. This yields a set of <user query, paper> pairs. Annotators then evaluate whether each paper aligns with the requirements of the user query. The final test dataset consists of 98 positive samples and 102 negative samples.

D Dataset Examples

Table 12 shows the examples of queries and corresponding papers in RealScholarQuery.

E Prompt Templates

E.1 Prompts for Baselines

Table 13 exhibits the search query paraphrasing prompt for the baseline model Google with GPT4o .

Table 14 exhibits the prompt for the baseline model ChatGPT (search-enabled GPT-4o).

E.2 Prompt for Paper Selection

Table 15 shows the prompt for PaSa selector and gpt-4o to judge whether a paper matches the requirements of the user's query.

Table 16 presents the prompt template used with GPT-4o to automatically generate AutoScholarQuery. For each paper, we extract the Related Work section, input it into GPT-4o, and use the prompt to extract scholarly queries and their corresponding paper answers from the Related Work section.

<missing-text>

<missing-text>

Query: Give me papers about how to rank search results by the use of LLM

Query Date:

2024-10-01

Answer Papers:

 [0] Instruction Distillation Makes Large Language Models Efficient Zero-shot Rankers

 [1] Beyond Yes and No: Improving Zero-Shot LLM Rankers via Scoring Fine-Grained Relevance Labels

 [2] Large Language Models are Effective Text Rankers with Pairwise Ranking Prompting

 [3] A Setwise Approach for Effective and Highly Efficient Zero-shot Ranking with Large Language Models

 [4] RankVicuna: Zero-Shot Listwise Document Reranking with Open-Source Large Language Models

 [5] PaRaDe: Passage Ranking using Demonstrations with Large Language Models

[6] Is ChatGPT Good at Search? Investigating Large Language Models as Re-Ranking Agents

 [7] Large Language Models are Zero-Shot Rankers for Recommender Systems

 [8] TourRank: Utilizing Large Language Models for Documents Ranking with a Tournament-Inspired Strategy

 [9] ExaRanker: Explanation-Augmented Neural Ranker

 [10] RankRAG: Unifying Context Ranking with Retrieval-Augmented Generation in LLMs

 [11] Make Large Language Model a Better Ranker

 [12] LLM-RankFusion: Mitigating Intrinsic Inconsistency in LLM-based Ranking

 [13] Improving Zero-shot LLM Re-Ranker with Risk Minimization

 [14] Zero-Shot Listwise Document Reranking with a Large Language Model

 [15] Consolidating Ranking and Relevance Predictions of Large Language Models through Post-Processing

 [16] Re-Ranking Step by Step: Investigating Pre-Filtering for Re-Ranking with Large Language Models

 [17] Large Language Models for Relevance Judgment in Product Search

 [18] PromptReps: Prompting Large Language Models to Generate Dense and Sparse Representations for Zero-Shot Document Retrieval

 [19] Passage-specific Prompt Tuning for Passage Reranking in Question Answering with Large Language Models

 [20] When Search Engine Services meet Large Language Models: Visions and Challenges

 [21] RankZephyr: Effective and Robust Zero-Shot Listwise Reranking is a Breeze!

 [22] Rank-without-GPT: Building GPT-Independent Listwise Rerankers on Open-Source Large Language Models

 [23] MuGI: Enhancing Information Retrieval through Multi-Text Generation Integration with Large Language Models

 [24] Discrete Prompt Optimization via Constrained Generation for Zero-shot Re-ranker

 [25] REAR: A Relevance-Aware Retrieval-Augmented Framework for Open-Domain Question Answering

 [26] Agent4Ranking: Semantic Robust Ranking via Personalized Query Rewriting Using Multi-agent LLM

 [27] FIRST: Faster Improved Listwise Reranking with Single Token Decoding

 [28] Leveraging LLMs for Unsupervised Dense Retriever Ranking

 [29] Unsupervised Contrast-Consistent Ranking with Language Models

 [30] Enhancing Legal Document Retrieval: A Multi-Phase Approach with Large Language Models

 [31] Found in the Middle: Permutation Self-Consistency Improves Listwise Ranking in Large Language Models

 [32] Fine-Tuning LLaMA for Multi-Stage Text Retrieval

 [33] Zero-shot Audio Topic Reranking using Large Language Models

 [34] Uncovering ChatGPT's Capabilities in Recommender Systems

 [35] Cognitive Personalized Search Integrating Large Language Models with an Efficient Memory Mechanism

 [36] Towards More Relevant Product Search Ranking Via Large Language Models: An Empirical Study

 [37] Pretrained Language Model based Web Search Ranking: From Relevance to Satisfaction

 [38] Open-source large language models are strong zero-shot query likelihood models for document ranking

Table 12: Examples of queries and corresponding papers in RealScholarQuery.

The prompt for search query paraphrase.

Generate a search query suitable for Google based on the given academic paper-related query. Here's the structure and requirements for generating the search query:

Understand the Query: Read and understand the given specific academic query.

Identify Key Elements: Extract the main research field and the specific approaches or topics mentioned in the query.

Formulate the Search Query: Combine these elements into a concise query that includes terms indicating academic sources.

Do not add any site limitations to your query.

[User's Query]: {user\_query}

[Generated Search Query]:

Table 13: The prompt for search query paraphrase.

The prompt for ChatGPT (search-enabled GPT-4o).

[User's Query]

You should return the Arxiv papers. You should provide more than 10 papers you searched in JSON format:

{"paper\_1": {"title": , 'authors': , 'link': }, "paper\_2": {"title": , 'authors': , 'link': }}

Table 14: The prompt for Chatgpt (search-enabled GPT-4o).

The prompt for paper selection.

You are an elite researcher in the field of AI, conducting research on {user\_query}. Evaluate whether the following paper fully satisfies the detailed requirements of the user query and provide your reasoning. Ensure that your decision and reasoning are consistent.

Searched Paper:

Title: {title}

Abstract: {abstract}

User Query: {user\_query}

Output format: Decision: True/False

Reason:...

Decision:

Table 15: The prompt used with pasa selector or GPT-4o to judge the selection of the paper.

The prompt for AutoScholarQuery generation.

You are provided a 'Related Work' section of a research paper. The researcher reviewed the relevant work, conducted a literature survey, and cited corresponding references in this text (enclosed by '\cite' tags with IDs). Can you guess what research questions the researcher might have posed when preparing this text? The answers to these questions should be the references cited in this passage. Please list questions and provide the corresponding answers.

[Requirements:]

 1. Craft questions similar to those a researcher would pose when reviewing related works, such as 'Which paper studied ...?', 'Any works about...?', 'Could you provide me some works...?'

 2. Construct the question-answer pairs based on [Section from A Research Paper]. The answer should be the cited papers in [Section from A Research Paper].

 3. Do not ask questions including "or" or "and" that may involve more than one condition.

 4. Clarity: Formulate questions clearly and unambiguously to prevent confusion.

 5. Contextual Definitions: Include explanations or definitions for specialized terms and concepts used in the questions.

 6. Format the output as a JSON array containing five objects corresponding to the three question-answer pairs.

Here are some examples:

[Begin of examples]

{Section from A Research Paper-1}

{OUTPUT-1}

{Section from A Research Paper-2}

{OUTPUT-2}

{Section from A Research Paper-3}

{OUTPUT-3}

[End of examples]

{Section from A Research Paper} [OUTPUT]:

Table 16: The prompt used with GPT-4o to automatically generate AutoScholarQuery.